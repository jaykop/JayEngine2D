//		1st case
//    |----------||----------|
//    |		     ||		     |
//    |   spt1	 ||   spt2   |
//    |		     ||		     |
//    |----------||----------|
//
if (spt1->GetPosition().x < spt2->GetPosition().x)
{
	vec3 diff = (spt2->GetPosition() - spt1->GetPosition()).Absolute();

	//		1-1st case
	//    |----------|
	//    |		     ||----------|
	//    |   spt1	 ||		     |
	//    |		     ||   spt2   |
	//    |----------||		     |
	//				  |----------|
	if (diff.x > diff.y)
	{
		spt1->SetPosition(vec3(spt2->GetPosition().x - spt2->GetScale().x / 2 - spt1->GetScale().x / 2,
			spt1->GetPosition().y, spt1->GetPosition().z));

		spt2->SetPosition(vec3(spt1->GetPosition().x + spt1->GetScale().x / 2 + spt2->GetScale().x / 2,
			spt2->GetPosition().y, spt2->GetPosition().z));
	}

	//		1-1-1st case					1-1-2nd case
	//    |----------|					|----------|
	//    |		     |					|		   |
	//    |   spt1	 |					|   spt2   |
	//    |		     |					|		   |
	//    |----------|					|----------|
	//			|----------|	|----------|
	//			|		   |	|		   |
	//			|   spt2   |	|   spt1   |
	//			|		   |	|		   |
	//			|----------|	|----------|
	//
	else
	{
		// 1-1-1st case
		if (spt1->GetPosition().y > spt2->GetPosition().y)
		{
			spt1->SetPosition(vec3(spt1->GetPosition().x,
				spt2->GetPosition().y + spt2->GetScale().y / 2 + spt1->GetScale().y / 2,
				spt1->GetPosition().z));

			spt2->SetPosition(vec3(spt2->GetPosition().x,
				spt1->GetPosition().y - spt1->GetScale().y / 2 - spt2->GetScale().y / 2,
				spt2->GetPosition().z));
		}

		// 1-1-2nd case
		else
		{
			spt1->SetPosition(vec3(spt1->GetPosition().x,
				spt2->GetPosition().y - spt2->GetScale().y / 2 - spt1->GetScale().y / 2,
				spt1->GetPosition().z));

			spt2->SetPosition(vec3(spt2->GetPosition().x,
				spt1->GetPosition().y + spt1->GetScale().y / 2 + spt2->GetScale().y / 2,
				spt2->GetPosition().z));
		}
	}
}

//		2nd case
//    |----------||----------|
//    |		     ||		     |
//    |   spt2	 ||   spt1   |
//    |		     ||		     |
//    |----------||----------|
//
else
{
	vec3 diff = (spt1->GetPosition() - spt2->GetPosition()).Absolute();

	//		2-1st case
	//    |----------|
	//    |		     ||----------|
	//    |   spt2	 ||		     |
	//    |		     ||   spt1   |
	//    |----------||		     |
	//				  |----------|
	if (diff.x > diff.y)
	{
		spt1->SetPosition(vec3(spt2->GetPosition().x + spt2->GetScale().x / 2 + spt1->GetScale().x / 2,
			spt1->GetPosition().y, spt1->GetPosition().z));

		spt2->SetPosition(vec3(spt1->GetPosition().x - spt1->GetScale().x / 2 - spt2->GetScale().x / 2,
			spt2->GetPosition().y, spt2->GetPosition().z));
	}

	//		2-1-1st case					2-1-2nd case
	//    |----------|					|----------|
	//    |		     |					|		   |
	//    |   spt2	 |					|   spt1   |
	//    |		     |					|		   |
	//    |----------|					|----------|
	//			|----------|	|----------|
	//			|		   |	|		   |
	//			|   spt1   |	|   spt2   |
	//			|		   |	|		   |
	//			|----------|	|----------|
	//
	else
	{
		// 2-1-1st case
		if (spt1->GetPosition().y < spt2->GetPosition().y)
		{
			spt1->SetPosition(vec3(spt1->GetPosition().x,
				spt2->GetPosition().y - spt2->GetScale().y / 2 - spt1->GetScale().y / 2,
				spt1->GetPosition().z));

			spt2->SetPosition(vec3(spt2->GetPosition().x,
				spt1->GetPosition().y + spt1->GetScale().y / 2 + spt2->GetScale().y / 2,
				spt2->GetPosition().z));
		}

		// 2-1-2nd case
		else
		{
			spt1->SetPosition(vec3(spt1->GetPosition().x,
				spt2->GetPosition().y + spt2->GetScale().y / 2 + spt1->GetScale().y / 2,
				spt1->GetPosition().z));

			spt2->SetPosition(vec3(spt2->GetPosition().x,
				spt1->GetPosition().y - spt1->GetScale().y / 2 - spt2->GetScale().y / 2,
				spt2->GetPosition().z));
		}
	}
}

// Reflect 1st sprite
// Get 1st body's edges 
Vertices body2 = GetVertices(spt2);
vec3 body2edge_start, body2edge_end;
for (int i = 0; i < 4; ++i)
{
	if (i == 3)
	{
		body2edge_start = body2[i];
		body2edge_end = body2[0];
	}

	else
	{
		body2edge_start = body2[i];
		body2edge_end = body2[i + 1];
	}

	// Get collided edge
	//if (Get2ndBoxEdge(body2edge_start, body2edge_end, spt1))
	//break;
}

vec3 edge_norm = (body2edge_end - body2edge_start).Rotation(90.f);
vec3 new_Velocity = spt1->GetRigidBody()->GetVelocity().Reflection(edge_norm);

//This is line - OBB collision method
float greatest_tmin = 0, smallest_tmax = 100000.f;
Vertices body1 = GetVertices(sprite1);
//Get 2nd body's edges 
for (int j = 0; j < 4; ++j)
{
	vec3 body1edge_start, body1edge_end;
	if (j == 3)
	{
		body1edge_start = body1[j];
		body1edge_end = body1[0];
	}

	else
	{
		body1edge_start = body1[j];
		body1edge_end = body1[j + 1];
	}

	Math::boolVec output = Math::IntersectOf2Lines(body1edge_start, body1edge_end,
		body2edge_start, body2edge_end);

	//Assign proper valuse
	if (output.boolean)
	{
		if (tx_Toggle)
		{
			tx_min = tx_max = output.vector.x;
			ty_min = ty_max = output.vector.y;
			tx_Toggle = false;
		}

		if (output.vector.x > tx_max) tx_max = output.vector.x;
		if (output.vector.x < tx_min) tx_min = output.vector.x;
		if (output.vector.y > ty_max) ty_max = output.vector.y;
		if (output.vector.y < ty_min) ty_min = output.vector.y;
	}
}

if (tx_max > ty_max) smallest_tmax = ty_max;
else smallest_tmax = tx_max;

if (tx_min < ty_min) greatest_tmin = ty_min;
else greatest_tmin = tx_min;

if (greatest_tmin > smallest_tmax)
return false;

return true;

 bool IntersectRayVsBox(BoundingBox  a_kBox,  
                           Ray          a_kRay,   
                           out float    a_fDist,  
                           out int      a_nFace)  
    {  
        a_nFace = -1;  
        a_fDist = float.MaxValue;  
 
        // Preform the collision query  
        float? fParam = a_kRay.Intersects(a_kBox);  
 
        // No collision, return false.  
        if(fParam.HasValue == false)  
            return false;  
 
        // Asign the distance along the ray our intersection point is  
        a_fDist = fParam.Value;  
 
        // Compute the intersection point  
        Vector3 vIntersection = a_kRay.Position + a_kRay.Direction * a_fDist;  
 
        // Determine the side of the box the ray hit, this is slower than  
        // more obvious methods but it's extremely tolerant of numerical  
        // drift (aka rounding errors)  
        Vector3 vDistMin = vIntersection - a_kBox.Min;  
        Vector3 vDistMax = vIntersection - a_kBox.Max;  
 
        vDistMin.X = (float)Math.Abs(vDistMin.X);  
        vDistMin.Y = (float)Math.Abs(vDistMin.Y);  
        vDistMin.Z = (float)Math.Abs(vDistMin.Z);  
 
        vDistMax.X = (float)Math.Abs(vDistMax.X);  
        vDistMax.Y = (float)Math.Abs(vDistMax.Y);  
        vDistMax.Z = (float)Math.Abs(vDistMax.Z);  
 
        // Start off assuming that our intersection point is on the  
        // negative x face of the bounding box.  
        a_nFace        = 0;  
        float fMinDist = vDistMin.X;  
          
        // +X  
        if(vDistMax.X < fMinDist)  
        {  
            a_nFace  = 1;  
            fMinDist = vDistMax.X;  
        }  
 
        // -Y  
        if(vDistMin.Y < fMinDist)  
        {  
            a_nFace  = 2;  
            fMinDist = vDistMin.Y;  
        }  
 
        // +Y  
        if(vDistMax.Y < fMinDist)  
        {  
            a_nFace  = 3;  
            fMinDist = vDistMax.Y;  
        }  
 
        // -Z  
        if(vDistMin.Z < fMinDist)  
        {  
            a_nFace  = 4;  
            fMinDist = vDistMin.Z;  
        }  
 
        // +Z  
        if(vDistMax.Z < fMinDist)  
        {  
            a_nFace  = 5;  
            fMinDist = vDistMin.Z;  
        }  
 
        return true;  
    } 


		bool hooker[4] = { false, false, false, false };
	vec3 collided_edge[4] = { vec3(), vec3(), vec3(), vec3() };
	vec3 the_edge;
	int  edgeChecker = 0;

	// Put first body in
	for (int i = 0; i < 4; ++i)
	{
		// Put second body in
		for (int j = 0; j < 4; ++j)
		{
			// Check each index cases
			if (j == 3 && i == 3)
			{
				// Calculate and check
				hooker[0] = Math::LineIntersection(body1[i], body1[0],
					body2[j], body2[0]);
				// Get the edge
				the_edge = collided_edge[0] = body2[0] - body2[j];
				if (hooker[0]) ++edgeChecker;
			}
			else if (j != 3 && i == 3)
			{
				hooker[1] = Math::LineIntersection(body1[i], body1[0],
					body2[j], body2[j + 1]);
				the_edge = collided_edge[1] = body2[j + 1] - body2[j];
				if (hooker[1]) ++edgeChecker;
			}
			else if (j == 3 && i != 3)
			{
				hooker[2] = Math::LineIntersection(body1[i], body1[i + 1],
					body2[j], body2[0]);
				the_edge = collided_edge[2] = body2[0] - body2[j];
				if (hooker[2]) ++edgeChecker;
			}
			else
			{
				hooker[3] = Math::LineIntersection(body1[i], body1[i + 1],
					body2[j], body2[j + 1]);
				the_edge = collided_edge[3] = body2[j + 1] - body2[j];
				if (hooker[3]) ++edgeChecker;
			}

			// If there are multiple collided line,
			// then calculate the edges' distances
			if (edgeChecker > 1)
			{

				return collided_edge;
			}

			else
				return the_edge;
		}
		//If got the answer, quit the loop
		if (hooker[0] || hooker[1] || hooker[2] || hooker[3])
			return collided_edge;
	}



	======================================================

		// Get spt2's collded line(edge) to set reflected velocity

	// Get the vertice got 2nd sprite's inside 
	float distance[4] = { 0 };
	float shortest = distance[0] = Math::DistanceOf2Points(body1[0], spt1->GetPosition());;
	int	shortest_index = 0;

	// Calculate which one is the shorest from the 2nd sprite's middle point(position)
	// So, get the vertice got 2nd sprite's inside 
	for (int index = 1; index < 4; ++index)
	{
		distance[index] = Math::DistanceOf2Points(body1[index], spt1->GetPosition());
		if (shortest > distance[index])
		{
			shortest = distance[index];
			shortest_index = index;
		}
	}

	// This is the one
	body1[shortest_index];

	bool hooker[4] = { false, false, false, false };
	vec3 collided_edge[4] = { vec3(), vec3(), vec3(), vec3() };
	vec3 the_edge;
	int  edgeChecker = 0;

	// Put first body in
	for (int i = 0; i < 4; ++i)
	{
		// Put second body in
		for (int j = 0; j < 4; ++j)
		{
			// Check each index cases
			if (j == 3 && i == 3)
			{
				// Calculate and check
				hooker[0] = Math::LineIntersection(body1[i], body1[0],
					body2[j], body2[0]);
				// Get the edge
				the_edge = collided_edge[0] = body2[0] - body2[j];
				if (hooker[0]) 
					++edgeChecker;
			}
			else if (j != 3 && i == 3)
			{
				hooker[1] = Math::LineIntersection(body1[i], body1[0],
					body2[j], body2[j + 1]);
				the_edge = collided_edge[1] = body2[j + 1] - body2[j];
				if (hooker[1]) 
					++edgeChecker;
			}
			else if (j == 3 && i != 3)
			{
				hooker[2] = Math::LineIntersection(body1[i], body1[i + 1],
					body2[j], body2[0]);
				the_edge = collided_edge[2] = body2[0] - body2[j];
				if (hooker[2]) 
					++edgeChecker;
			}
			else
			{
				hooker[3] = Math::LineIntersection(body1[i], body1[i + 1],
					body2[j], body2[j + 1]);
				the_edge = collided_edge[3] = body2[j + 1] - body2[j];
				if (hooker[3]) 
					++edgeChecker;
			}

			// If there are multiple collided line,
			// then calculate the edges' distances
			if (edgeChecker > 1)
			{

				
			}

			else
				return the_edge;
		}
		//If got the answer, quit the loop
		//if (hooker[0] || hooker[1] || hooker[2] || hooker[3])
		//	return collided_edge;
	}

	newy = sin(angle) * (oldy - centery) + cos(angle) * (oldx - centerx);
newx = cos(angle) * (oldx - centerx) - sin(angle) * (oldy - centery);
(you may need to adjust this depending on how angle is supposed to be measured, I'll leave that to you, since you didn't specify)

Then hit test, the normal way:

return (newy > centery - height / 2) && (newy < centery + height / 2) 
    && (newx > centerx - width / 2) && (newx < centerx + width / 2);